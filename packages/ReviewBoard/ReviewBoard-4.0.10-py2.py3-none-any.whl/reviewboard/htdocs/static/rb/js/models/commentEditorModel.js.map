{"version":3,"sources":["commentEditorModel.es6.js"],"names":[],"mappings":"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","file":"commentEditorModel.js","sourcesContent":["/**\n * Represents the state for editing a new or existing draft comment.\n *\n * From here, a comment can be created, edited, or deleted.\n *\n * This will provide state on what actions are available on a comment,\n * informative text, dirty states, existing published comments on the\n * same region this comment is on, and more.\n *\n * Attributes:\n *     canDelete (boolean):\n *         Whether the draft comment can be deleted.\n *\n *     canEdit (boolean):\n *         Whether the draft comment can be edited.\n *\n *     canSave (boolean):\n *         Whether the draft comment can be saved.\n *\n *     editing (boolean):\n *         True if the comment is currently being edited.\n *\n *     extraData (object):\n *         The draft state for the comment's extra data.\n *\n *     comment (RB.BaseComment):\n *         The comment model.\n *\n *     dirty (boolean):\n *         True if the draft comment has been edited but not saved.\n *\n *     openIssue (boolean):\n *         Whether the comment opens an issue.\n *\n *     publishedComments (Array of RB.BaseComment):\n *         The thread of previous comments that this draft is a reply to, if\n *         applicable.\n *\n *     publishedCommentsType (string):\n *         The type of comment that this draft is a reply to, if applicable.\n *\n *     reviewRequest (RB.ReviewRequest):\n *         The review request that the comment is on.\n *\n *     richText (boolean):\n *         Whether the comment is formatted in Markdown.\n *\n *     text (string):\n *         The comment's text.\n */\nRB.CommentEditor = Backbone.Model.extend(_.defaults({\n    /**\n     * Return the default values for the model attributes.\n     *\n     * Returns:\n     *     object:\n     *     The default values for the attributes.\n     */\n    defaults() {\n        const userSession = RB.UserSession.instance;\n\n        return {\n            canDelete: false,\n            canEdit: undefined,\n            canSave: false,\n            editing: false,\n            extraData: {},\n            comment: null,\n            dirty: false,\n            openIssue: userSession.get('commentsOpenAnIssue'),\n            publishedComments: [],\n            publishedCommentsType: null,\n            requireVerification: false, // TODO: add a user preference for this.\n            reviewRequest: null,\n            richText: userSession.get('defaultUseRichText'),\n            text: '',\n        };\n    },\n\n    /**\n     * Initialize the comment editor.\n     */\n    initialize() {\n        const reviewRequest = this.get('reviewRequest');\n\n        this.on('change:comment', this._updateFromComment, this);\n        this._updateFromComment();\n\n        /*\n         * Unless a canEdit value is explicitly given, we want to compute\n         * the proper state.\n         */\n        if (this.get('canEdit') === undefined) {\n            reviewRequest.on('change:hasDraft', this._updateCanEdit, this);\n            this._updateCanEdit();\n        }\n\n        this.on('change:dirty', (model, dirty) => {\n            const reviewRequestEditor = this.get('reviewRequestEditor');\n\n            if (reviewRequestEditor) {\n                if (dirty) {\n                    reviewRequestEditor.incr('editCount');\n                } else {\n                    reviewRequestEditor.decr('editCount');\n                }\n            }\n        });\n\n        this.on(\n            'change:openIssue change:requireVerification ' +\n            'change:richText change:text',\n            () => {\n                if (this.get('editing')) {\n                    this.set('dirty', true);\n                    this._updateState();\n                }\n            });\n\n        this._updateState();\n\n        this._setupExtraData();\n    },\n\n    /**\n     * Set the editor to begin editing a new or existing comment.\n     */\n    beginEdit() {\n        console.assert(this.get('canEdit'),\n                       'beginEdit() called when canEdit is false.');\n        console.assert(this.get('comment'),\n                       'beginEdit() called when no comment was first set.');\n\n        this.set({\n            dirty: false,\n            editing: true,\n        });\n\n        this._updateState();\n    },\n\n    /**\n     * Delete the current comment, if it can be deleted.\n     *\n     * This requires that there's a saved comment to delete.\n     *\n     * The editor will be marked as closed, requiring a new call to beginEdit.\n     */\n    deleteComment() {\n        console.assert(this.get('canDelete'),\n                       'deleteComment() called when canDelete is false.');\n\n        const comment = this.get('comment');\n        comment.destroy({\n            success: () => {\n                this.trigger('deleted');\n                this.close();\n            },\n        });\n    },\n\n    /**\n     * Cancel editing of a comment.\n     *\n     * If there's a saved comment and it's been made empty, it will end\n     * up being deleted. Then this editor will be marked as closed,\n     * requiring a new call to beginEdit.\n     */\n    cancel() {\n        const comment = this.get('comment');\n\n        this.off('change:comment', this._updateFromComment, this);\n\n        if (comment) {\n            comment.destroyIfEmpty();\n            this.trigger('canceled');\n        }\n\n        this.close();\n    },\n\n    /**\n     * Close editing of the comment.\n     *\n     * The comment state will be reset, and the \"closed\" event will be\n     * triggered.\n     *\n     * To edit a comment again after closing it, the proper state must be\n     * set again and beginEdit must be called.\n     */\n    close() {\n        /* Set this first, to prevent dirty firing. */\n        this.set('editing', false);\n\n        this.set({\n            comment: null,\n            dirty: false,\n            extraData: new RB.ExtraData(),\n            text: '',\n        });\n\n        this.trigger('closed');\n    },\n\n    /**\n     * Save the comment.\n     *\n     * If this is a new comment, it will be created on the server.\n     * Otherwise, the existing comment will be updated.\n     *\n     * The editor will not automatically be marked as closed. That is up\n     * to the caller.\n     *\n     * Args:\n     *     options (object, optional):\n     *         Options for the save operation.\n     *\n     *     context (object, optional):\n     *         The context to use when calling callbacks.\n     */\n    save(options={}, context=undefined) {\n        console.assert(this.get('canSave'),\n                       'save() called when canSave is false.');\n\n        const extraData =  _.clone(this.get('extraData'));\n        extraData.require_verification = this.get('requireVerification');\n\n        const comment = this.get('comment');\n        comment.set({\n            text: this.get('text'),\n            issueOpened: this.get('openIssue'),\n            extraData: extraData,\n            richText: this.get('richText'),\n            includeTextTypes: 'html,raw,markdown',\n        });\n\n        comment.save({\n            success: () => {\n                this.set('dirty', false);\n                this.trigger('saved');\n\n                if (_.isFunction(options.success)) {\n                    options.success.call(context);\n                }\n            },\n\n            error: _.isFunction(options.error)\n                   ? options.error.bind(context)\n                   : undefined,\n        });\n    },\n\n    /**\n     * Update the state of the editor from the currently set comment.\n     */\n    _updateFromComment() {\n        const oldComment = this.previous('comment');\n        const comment = this.get('comment');\n\n        if (oldComment) {\n            oldComment.destroyIfEmpty();\n        }\n\n        if (comment) {\n            const defaultRichText = this.defaults().richText;\n\n            /*\n             * Set the attributes based on what we know at page load time.\n             *\n             * Note that it is *possible* that the comments will have changed\n             * server-side since loading the page (if the user is reviewing\n             * the same diff in two tabs). However, it's unlikely.\n             *\n             * Doing this before the ready() call ensures that we'll have the\n             * text and state up-front and that it won't overwrite what the\n             * user has typed after load.\n             *\n             * Note also that we'll always want to use our default richText\n             * value if it's true, and we'll fall back on the comment's value\n             * if false. This is so that we can keep a consistent experience\n             * when the \"Always edit Markdown by default\" value is set.\n             */\n            this.set({\n                dirty: false,\n                extraData: comment.get('extraData'),\n                openIssue: comment.get('issueOpened') === null\n                           ? this.defaults().openIssue\n                           : comment.get('issueOpened'),\n                requireVerification: comment.requiresVerification(),\n                richText: defaultRichText || !!comment.get('richText'),\n            });\n\n            /*\n             * We'll try to set the one from the appropriate text fields, if it\n             * exists and is not empty. If we have this, then it came from a\n             * previous save. If we don't have it, we'll fall back to \"text\",\n             * which should be normalized content from the initial page load.\n             */\n            const textFields = (comment.get('richText') || !defaultRichText\n                                ? comment.get('rawTextFields')\n                                : comment.get('markdownTextFields'));\n\n            this.set('text',\n                     !_.isEmpty(textFields)\n                     ? textFields.text\n                     : comment.get('text'));\n\n            comment.ready({\n                ready: this._updateState,\n            }, this);\n        }\n    },\n\n    /**\n     * Update the canEdit state of the editor.\n     *\n     * This is based on the authentication state of the user, and\n     * whether or not there's an existing draft for the review request.\n     */\n    _updateCanEdit() {\n        const reviewRequest = this.get('reviewRequest');\n        const userSession = RB.UserSession.instance;\n\n        this.set('canEdit',\n                 userSession.get('authenticated') &&\n                 !userSession.get('readOnly') &&\n                 !reviewRequest.get('hasDraft'));\n    },\n\n    /**\n     * Update the capability states of the editor.\n     *\n     * Some of the can* properties will change to reflect the various\n     * actions that can be performed with the editor.\n     */\n    _updateState() {\n        const canEdit = this.get('canEdit');\n        const editing = this.get('editing');\n        const comment = this.get('comment');\n\n        this.set({\n            canDelete: canEdit && editing && comment && !comment.isNew(),\n            canSave: canEdit && editing && this.get('text') !== '',\n        });\n    },\n}, RB.ExtraDataMixin));\n"]}