{"version":3,"sources":["diffFragmentQueueView.es6.js"],"names":[],"mappings":"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","file":"diffFragmentQueueView.js","sourcesContent":["/**\n * Queues loading of diff fragments from a page.\n *\n * This is used to load diff fragments one-by-one, and to intelligently\n * batch the loads to only fetch at most one set of fragments per file.\n */\nRB.DiffFragmentQueueView = Backbone.View.extend({\n    /**\n     * Initialize the queue.\n     *\n     * Args:\n     *     options (object):\n     *         Options passed to this view.\n     *\n     * Returns:\n     *     containerPrefix (string):\n     *         The prefix to prepend to diff comment IDs when forming\n     *         container element IDs.\n     *\n     *     diffFragmentViewOptions (object, optional):\n     *         Options to pass to each :js:class:`RB.DiffFragmentView` that's\n     *         created.\n     *\n     *     reviewRequestPath (string):\n     *         The URL for the review request that diff fragments will be\n     *         loaded from.\n     *\n     *     queueName (string):\n     *         The name of the diff loading queue.\n     */\n    initialize(options) {\n        this._containerPrefix = options.containerPrefix;\n        this._diffFragmentViewOptions = options.diffFragmentViewOptions;\n        this._fragmentsBasePath =\n            `${options.reviewRequestPath}_fragments/diff-comments/`;\n        this._queueName = options.queueName;\n\n        this._queue = {};\n        this._saved = {};\n    },\n\n    /**\n     * Queue the load of a diff fragment from the server.\n     *\n     * This will be added to a list, which will fetch the comments in batches\n     * based on file IDs.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment to queue.\n     *\n     *     key (string):\n     *         The key for the queue. Each comment with the same key will be\n     *         loaded in a batch. This will generally be the ID of a file.\n     *\n     *     onFragmentRendered (function, optional):\n     *         Optional callback for when the view for the fragment has\n     *         rendered. Contains the view as a parameter.\n     */\n    queueLoad(commentID, key, onFragmentRendered) {\n        const queue = this._queue;\n\n        if (!queue[key]) {\n            queue[key] = [];\n        }\n\n        queue[key].push({\n            commentID: commentID,\n            onFragmentRendered: onFragmentRendered || null,\n        });\n    },\n\n    /**\n     * Save a comment's loaded diff fragment for the next load operation.\n     *\n     * If the comment's diff fragment was already loaded, it will be\n     * temporarily stored until the next load operation involving that\n     * comment. Instead of loading the fragment from the server, the saved\n     * fragment's HTML will be used instead.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment to save.\n     */\n    saveFragment(commentID) {\n        const $el = this._getCommentContainer(commentID);\n\n        if ($el.length === 1 && $el.data('diff-fragment-view')) {\n            this._saved[commentID] = $el.html();\n        }\n    },\n\n    /**\n     * Load all queued diff fragments.\n     *\n     * The diff fragments for each keyed set in the queue will be loaded as\n     * a batch. The resulting fragments will be injected into the DOM.\n     *\n     * Any existing fragments that were saved will be loaded from the cache\n     * without requesting them from the server.\n     *\n     * Args:\n     *     onDone (function, optional):\n     *         Callback for when all fragments have been loaded.\n     */\n    loadFragments(onDone) {\n        if (_.isEmpty(this._queue) && _.isEmpty(this._saved)) {\n            if (_.isFunction(onDone)) {\n                onDone();\n            }\n\n            return;\n        }\n\n        const queueName = this._queueName;\n\n        _.each(this._queue, queuedLoads => {\n            $.funcQueue(queueName).add(() => {\n                const pendingCommentIDs = [];\n                const onFragmentRenderedFuncs = {};\n\n                /*\n                 * Check if there are any comment IDs that have been saved.\n                 * We don't need to reload these from the server.\n                 */\n                for (let i = 0; i < queuedLoads.length; i++) {\n                    const queuedLoad = queuedLoads[i];\n                    const commentID = queuedLoad.commentID;\n                    const onFragmentRendered =\n                        _.isFunction(queuedLoad.onFragmentRendered)\n                        ? queuedLoad.onFragmentRendered\n                        : null;\n\n                    if (this._saved.hasOwnProperty(commentID)) {\n                        const html = this._saved[commentID];\n\n                        const container = this._getCommentContainer(commentID);\n                        console.assert(container);\n\n                        let view = container.data('diff-fragment-view');\n\n                        if (view) {\n                            view.$el.html(html);\n                            view.render();\n                        } else {\n                            view = this._renderFragment(container, commentID,\n                                                        html);\n                        }\n\n                        if (onFragmentRendered) {\n                            onFragmentRendered(view);\n                        }\n\n                        delete this._saved[commentID];\n                    } else {\n                        pendingCommentIDs.push(commentID);\n                        onFragmentRenderedFuncs[commentID] =\n                            onFragmentRendered;\n                    }\n                }\n\n                if (pendingCommentIDs.length > 0) {\n                    /*\n                     * There are some comment IDs we don't have. Load these\n                     * from the server.\n                     *\n                     * Once these are loaded, they'll call next() on the queue\n                     * to process the next batch.\n                     */\n                    this._loadDiff(pendingCommentIDs.join(','), {\n                        queueName: queueName,\n                        onFragmentRendered: (commentID, view) => {\n                            if (onFragmentRenderedFuncs[commentID]) {\n                                onFragmentRenderedFuncs[commentID](view);\n                            }\n                        },\n                        onDone: () => $.funcQueue(queueName).next(),\n                    });\n                } else {\n                    /*\n                     * We processed all we need to process above. Go to the\n                     * next queue.\n                     */\n                    $.funcQueue(queueName).next();\n                }\n            });\n        });\n\n        if (_.isFunction(onDone)) {\n            $.funcQueue(queueName).add(() => {\n                onDone();\n                $.funcQueue(queueName).next();\n            });\n        }\n\n        // Clear the list.\n        this._queue = {};\n\n        $.funcQueue(queueName).start();\n    },\n\n    /**\n     * Return the container for a particular comment.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment.\n     *\n     * Returns:\n     *     jQuery:\n     *     The comment container, wrapped in a jQuery element. The caller\n     *     may want to check the length to be sure the container was found.\n     */\n    _getCommentContainer(commentID) {\n        return $(`#${this._containerPrefix}_${commentID}`);\n    },\n\n    /**\n     * Load a diff fragment for the given comment IDs and options.\n     *\n     * This will construct the URL for the relevant diff fragment and load\n     * it from the server.\n     *\n     * Args:\n     *     commentIDs (string):\n     *         A string of comment IDs to load fragments for.\n     *\n     *     options (object, optional):\n     *         Options for the loaded diff fragments.\n     *\n     * Option Args:\n     *     linesOfContext (string):\n     *         The lines of context to load for the diff. This is a string\n     *         containing a comma-separated set of line counts in the form\n     *         of ``numLinesBefore,numLinesAfter``.\n     *\n     *     onDone (function):\n     *         A function to call after the diff has been loaded.\n     *\n     *     queueName (string):\n     *         The name of the load queue. This is used to load batches of\n     *         fragments sequentially.\n     */\n    _loadDiff(commentIDs, options={}) {\n        const containerPrefix = this._containerPrefix;\n        const queryArgs = [];\n        const onFragmentRendered = (_.isFunction(options.onFragmentRendered)\n                                    ? options.onFragmentRendered\n                                    : null);\n\n        if (options.linesOfContext !== undefined) {\n            queryArgs.push(`lines_of_context=${options.linesOfContext}`);\n        }\n\n        if (!containerPrefix.includes('draft')) {\n            queryArgs.push('allow_expansion=1');\n        }\n\n        queryArgs.push(TEMPLATE_SERIAL);\n\n        RB.apiCall({\n            url: `${this._fragmentsBasePath}${commentIDs}/`,\n            data: queryArgs.join('&'),\n            dataType: 'arraybuffer',\n            type: 'GET',\n            success: arrayBuffer => {\n                const dataView = new DataView(arrayBuffer);\n                const len = dataView.byteLength;\n                let pos = 0;\n                let totalFragments = 0;\n                let totalRenders = 0;\n                let done = false;\n\n                const onFragmentLoaded = (commentID, html) => {\n                    /* Set the HTML in the container. */\n                    const containerID = `#${containerPrefix}_${commentID}`;\n                    const $container = $(containerID);\n\n                    if ($container.length === 0) {\n                        /*\n                         * This doesn't actually exist. We may be dealing with\n                         * inconsistent state due to something missing in the\n                         * database. We don't want to break the page if this\n                         * happens, so log and skip the entry.\n                         */\n                        console.error('Unable to find container %s for ' +\n                                      'comment ID %s. There may be missing ' +\n                                      'state in the database.',\n                                      containerID, commentID);\n                    } else {\n                        const view = this._renderFragment(\n                            $(`#${containerPrefix}_${commentID}`),\n                            commentID,\n                            html);\n\n                        if (onFragmentRendered) {\n                            onFragmentRendered(commentID, view);\n                        }\n                    }\n\n                    totalRenders++;\n\n                    if (done && totalRenders === totalFragments &&\n                        _.isFunction(options.onDone)) {\n                        /*\n                         * We've parsed and rendered all fragments, so we're\n                         * officially done.\n                         */\n                        options.onDone();\n                    }\n                }\n\n                while (!done) {\n                    const parsed = this._parseDiffFragmentFromPayload(\n                        arrayBuffer, dataView, pos);\n\n                    totalFragments++;\n                    pos = parsed.pos;\n                    done = (pos >= len);\n\n                    parsed.load(onFragmentLoaded);\n                }\n            }\n        });\n    },\n\n    /**\n     * Parse a single diff fragment from the payload.\n     *\n     * This will parse out information about the fragment (the comment ID and\n     * HTML) and return a response containing the new position and a function\n     * to call in order to load the parsed fragment.\n     *\n     * Args:\n     *     arrayBuffer (ArrayBuffer):\n     *         The array buffer being parsed.\n     *\n     *     dataView (DataView):\n     *         The data view on top of the array buffer, used to extract\n     *         information.\n     *\n     *     pos (number):\n     *         The current position within the array buffer.\n     *\n     * Returns:\n     *     object:\n     *     An object with two keys:\n     *\n     *     ``pos``:\n     *         The next position to parse.\n     *\n     *     ``load``:\n     *         A function for loading the fragment content. This takes a\n     *         callback function as an argument containing ``commentID`` and\n     *         ``html`` arguments.\n     */\n    _parseDiffFragmentFromPayload(arrayBuffer, dataView, pos) {\n        /* Read the comment ID. */\n        const commentID = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the length of the HTML. */\n        const htmlLen = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the HTML position for later. */\n        const htmlStart = pos;\n        pos += htmlLen;\n\n        return {\n            pos: pos,\n            load(cb) {\n                RB.DataUtils.readBlobAsString(\n                    new Blob([arrayBuffer.slice(htmlStart,\n                                                htmlStart + htmlLen)]),\n                    html => cb(commentID, html));\n            },\n        };\n    },\n\n    /**\n     * Render a diff fragment on the page.\n     *\n     * This will set up a view for the diff fragment, if one is not already\n     * created, and render it on the page.\n     *\n     * It will also mark the fragment for updates with the scroll manager\n     * so that if the user is scrolled to a location past the fragment, the\n     * resulting size change for the fragment won't cause the page to jump.\n     *\n     * Args:\n     *     $container (jQuery):\n     *         The container element where the fragment will be injected.\n     *\n     *     commentID (number):\n     *         The ID of the comment.\n     *\n     *     html (string):\n     *         The HTML contents of the fragment.\n     */\n    _renderFragment($container, commentID, html) {\n        RB.scrollManager.markForUpdate($container);\n\n        $container.html(html);\n\n        let view = $container.data('diff-fragment-view');\n\n        if (!view) {\n            view = new RB.DiffFragmentView(_.defaults({\n                el: $container,\n                loadDiff: options => {\n                    RB.setActivityIndicator(true, {type: 'GET'});\n\n                    this._loadDiff(commentID, _.defaults({\n                        onDone() {\n                            RB.setActivityIndicator(false, {});\n\n                            if (options.onDone) {\n                                options.onDone();\n                            }\n                        },\n                    }, options));\n                },\n            }, this._diffFragmentViewOptions));\n            $container.data('diff-fragment-view', view);\n        }\n\n        view.render();\n\n        RB.scrollManager.markUpdated($container);\n\n        return view;\n    },\n});\n"]}