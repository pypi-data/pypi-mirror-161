{"version":3,"sources":["underscoreUtils.es6.js"],"names":[],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAC,aAAF,GAAkB,UAAS,SAAT,EAAoB,OAApB,EACuD;EAAA,IAA9C,WAA8C,uEAAlC,CAAC,SAAD,EAAY,OAAZ,EAAqB,UAArB,CAAkC;;EACrE,IAAI,CAAC,OAAL,EAAc;IACV,OAAO,SAAP;EACH;;EAED,MAAM,gBAAgB,GAAG,EAAzB;;EAEA,KAAK,IAAI,CAAC,GAAD,EAAM,KAAN,CAAT,IAAyB,MAAM,CAAC,OAAP,CAAe,SAAf,CAAzB,EAAoD;IAChD,IAAI,WAAW,CAAC,QAAZ,CAAqB,GAArB,KAA6B,CAAC,CAAC,UAAF,CAAa,KAAb,CAAjC,EAAsD;MAClD,gBAAgB,CAAC,GAAD,CAAhB,GAAwB,CAAC,CAAC,IAAF,CAAO,KAAP,EAAc,OAAd,CAAxB;IACH;EACJ;;EAED,OAAO,CAAC,CAAC,QAAF,CAAW,gBAAX,EAA6B,SAA7B,CAAP;AACH,CAfD;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,CAAC,CAAC,QAAF,GAAa,UAAS,IAAT,EAAe;EACxB,OAAO,MAAM;IACT,CAAC,CAAC,KAAF,CAAQ,IAAR;EACH,CAFD;AAGH,CAJD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,CAAC,CAAC,cAAF,GAAmB,UAAS,UAAT,EAAiC;EAAA,IAAZ,OAAY,uEAAJ,EAAI;EAChD,IAAI,cAAc,GAAG,KAArB;EAEA;AACJ;AACA;AACA;;EACI,OAAO,YAAW;IACd,IAAI,cAAJ,EAAoB;MAChB;IACH;;IAED,MAAM,OAAO,GAAG,IAAhB;IACA,MAAM,IAAI,GAAG,SAAb;IAEA,cAAc,GAAG,IAAjB;;IAEA,IAAI,EAAE,GAAG,MAAM;MACX,UAAU,CAAC,KAAX,CAAiB,OAAjB,EAA0B,IAA1B;MACA,cAAc,GAAG,KAAjB;IACH,CAHD;;IAKA,IAAI,OAAO,CAAC,KAAZ,EAAmB;MACf,EAAE,GAAG,CAAC,CAAC,QAAF,CAAW,EAAX,CAAL;IACH;;IAED,qBAAqB,CAAC,EAAD,CAArB;EACH,CApBD;AAqBH,CA5BD;AA+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAM,CAAC,MAAP,GAAgB,UAAS,GAAT,EAAc;EAC1B,OAAO,MAAM,CAAC,cAAP,CAAsB,MAAM,CAAC,cAAP,CAAsB,GAAtB,CAAtB,CAAP;AACH,CAFD","file":"underscoreUtils.js","sourcesContent":["/**\n * Bind callbacks to a context.\n *\n * Backbone.js's various ajax-related functions don't take a context\n * with their callbacks. This allows us to wrap these callbacks to ensure\n * we always have a desired context.\n *\n * Args:\n *     callbacks (object):\n *         An object which potentially includes callback functions.\n *\n *     context (any type):\n *         The context to bind to the callbacks.\n *\n *     methodNames (Array of string):\n *         An array of method names within ``callbacks`` to bind.\n *\n * Returns:\n *     object:\n *     A copy of the ``callbacks`` object, with the given ``methodNames`` bound\n *     to ``context``.\n */\n_.bindCallbacks = function(callbacks, context,\n                           methodNames=['success', 'error', 'complete']) {\n    if (!context) {\n        return callbacks;\n    }\n\n    const wrappedCallbacks = {};\n\n    for (let [key, value] of Object.entries(callbacks)) {\n        if (methodNames.includes(key) && _.isFunction(value)) {\n            wrappedCallbacks[key] = _.bind(value, context);\n        }\n    }\n\n    return _.defaults(wrappedCallbacks, callbacks);\n};\n\n\n/**\n * Return a function that will be called when the call stack has unwound.\n *\n * This will return a function that calls the provided function using\n * :js:func:`_.defer`.\n *\n * Args:\n *     func (function):\n *         The function to call.\n *\n * Returns:\n *     function:\n *     The wrapper function.\n */\n_.deferred = function(func) {\n    return () => {\n        _.defer(func);\n    };\n};\n\n\n/**\n * Return a function suitable for efficiently handling page layout.\n *\n * The returned function will use :js:func:`window.requestAnimationFrame` to\n * schedule the layout call. Once this function called, any subsequent calls\n * will be ignored until the first call has finished the layout work.\n *\n * Optionally, this can also defer layout work until the call stack has unwound.\n *\n * This is intended to be used as a resize event handler.\n *\n * Args:\n *     layoutFunc (function):\n *         The function to call to perform layout.\n *\n *     options (object):\n *         Options for the layout callback.\n *\n * Option Args:\n *     defer (boolean):\n *         If ``true``, the layout function will be called when the call stack\n *         has unwound after the next scheduled layout call.\n */\n_.throttleLayout = function(layoutFunc, options={}) {\n    let handlingLayout = false;\n\n    /*\n     * We don't want to use a fat arrow function here, since we need the\n     * caller's context to be preserved.\n     */\n    return function() {\n        if (handlingLayout) {\n            return;\n        }\n\n        const context = this;\n        const args = arguments;\n\n        handlingLayout = true;\n\n        let cb = () => {\n            layoutFunc.apply(context, args);\n            handlingLayout = false;\n        };\n\n        if (options.defer) {\n            cb = _.deferred(cb);\n        }\n\n        requestAnimationFrame(cb);\n    };\n};\n\n\n/*\n * Return the parent prototype for an object.\n *\n * Args:\n *     obj (object):\n *         An object.\n *\n * Returns:\n *     object:\n *     The object which is the parent prototype for the given ``obj``. This is\n *     roughly equivalent to what you'd get from ES6's ``super``.\n */\nwindow._super = function(obj) {\n    return Object.getPrototypeOf(Object.getPrototypeOf(obj));\n};\n"]}