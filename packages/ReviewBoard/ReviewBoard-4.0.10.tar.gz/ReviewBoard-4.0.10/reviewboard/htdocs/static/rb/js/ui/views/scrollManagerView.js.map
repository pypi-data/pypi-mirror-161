{"version":3,"sources":["scrollManagerView.es6.js"],"names":[],"mappings":"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","file":"scrollManagerView.js","sourcesContent":["/**\n * Manages behavior and UI related to scrolling the page.\n *\n * This can be used by the UI to track pending and completed updates to\n * elements that might affect the current scroll position, such as new content\n * being injected into the DOM or being hidden/shown. When such updates occur\n * that would cause a page jump, the scroll manager will fix the scroll\n * position to counteract the jump.\n *\n * When a view is ready to make a DOM change that would impact the display or\n * size of an element, it should call\n * :js:func:`RB.ScrollManagerView.markForUpdate` before updating the element.\n * After, it should call :js:func:`RB.ScrollManagerView.markUpdates`.\n *\n * Views that create floating elements at the top of the page (such as banners)\n * should increment :js:attr:`RB.ScrollManagerView.scrollYOffset` by the height\n * of the element, and decrement it when the element goes away. This will\n * ensure that when navigating to an element through the scroll manager that\n * the height of the floating element will be taken into consideration for\n * the positioning.\n *\n * Attributes:\n *     scrollYOffset (number):\n *         The offset to add when scrolling to a target element or position.\n *         Callers should only increment or decrement this, and should never\n *         set it directly.\n */\nRB.ScrollManagerView = Backbone.View.extend({\n    /**\n     * Initialize the scroll manager.\n     */\n    initialize() {\n        this.scrollYOffset = 0;\n\n        // This is used so that unit tests can create a dummy window.\n        this.window = window;\n\n        this._updateScrollPosScheduled = false;\n        this._pendingElements = new Map();\n        this._elements = new Map();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n    },\n\n    /**\n     * Scroll to a specific element on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element to scroll to.\n     */\n    scrollToElement($el) {\n        this.scrollToPosition($el.offset().top);\n    },\n\n    /**\n     * Scroll to a specific position on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     scrollY (number):\n     *         The Y position to scroll to.\n     */\n    scrollToPosition(scrollY) {\n        this._oldScrollY = scrollY;\n\n        /*\n         * We use this instead of a flag being passed around to functions\n         * because we might actually end up using a pre-scheduled update to\n         * the scroll position, rather than scheduling a new one.\n         */\n        this._useScrollYOffset = true;\n\n        /* Attempt to immedialely scroll to the desired position. */\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        /*\n         * Chrome (and possibly other browsers in the future) attempt to be\n         * smart about restoring the initial scroll position after the page\n         * has fully loaded. However, we want to control the position in this\n         * case (probably in response to something in the URL we're handling),\n         * so we want to disable Chrome's behavior. Fortunately, there's an\n         * API for that.\n         */\n        if ('scrollRestoration' in history) {\n            history.scrollRestoration = 'manual';\n        }\n\n        this._scheduleUpdateScrollPos(true);\n    },\n\n    /**\n     * Mark an element for update.\n     *\n     * This should be called when an element will be updated with new\n     * content/size/visibility. The current state of the element will be\n     * tracked. When the update has finished, :js:func:`markUpdated` should\n     * be called to finalize the update.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element being updated.\n     */\n    markForUpdate($el) {\n        console.assert($el.length === 1);\n\n        const oldOffset = $el.offset();\n\n        this._pendingElements.set($el[0], {\n            oldHeight: $el.outerHeight(),\n            oldOffset: {\n                left: oldOffset.left,\n                top: oldOffset.top,\n            },\n        });\n\n        if (this._oldScrollY === null) {\n            this._oldScrollY = this.window.pageYOffset;\n        }\n    },\n\n    /**\n     * Mark an element as having been updated.\n     *\n     * This will schedule a scroll position update, factoring in the size\n     * and position differences for the element and helping prevent a page\n     * jump if the update occurred before the current scroll position.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element that was updated.\n     */\n    markUpdated($el) {\n        console.assert($el.length === 1);\n\n        const el = $el[0];\n        const elInfo = this._pendingElements.get(el);\n\n        if (elInfo) {\n            elInfo.newHeight = $el.outerHeight();\n            elInfo.newOffset = $el.offset();\n\n            this._elements.set(el, elInfo);\n            this._pendingElements.delete(el);\n        }\n\n        this._scheduleUpdateScrollPos();\n    },\n\n    /**\n     * Schedule an update for the scroll position.\n     *\n     * This will schedule the scroll position to be updated to take into\n     * account any updated elements. The update will happen in the next\n     * available animation frame. Only one will ever be scheduled at a time.\n     */\n    _scheduleUpdateScrollPos() {\n        if (!this._updateScrollPosScheduled) {\n            this._updateScrollPosScheduled = true;\n\n            /*\n             * Ideally we would update the DOM and set the scroll position at\n             * the same time, synchronized, without waiting for an animation\n             * frame and preventing any kind of a jump. This would work okay\n             * in some browsers (Chrome and Firefox are pretty good at not\n             * jumping), but some -- Safari (as of 10.1), Internet Explorer\n             * (as of 11), and Edge (as of 38.14393) -- will still jump after\n             * our code executes.\n             *\n             * We can minimize that jump by performing the scroll update during\n             * an animation frame, getting it as close as possible to the DOM\n             * layout update.\n             */\n            this.window.requestAnimationFrame(\n                this._updateScrollPos.bind(this));\n        }\n    },\n\n    /**\n     * Update the scroll position to factor in any element updates.\n     *\n     * This will look for any tracked elements that have been updated\n     * earlier in the page (before the current scroll position). It will\n     * then update the scroll position to take those updates into account,\n     * helping prevent a page jump.\n     */\n    _updateScrollPos() {\n        const elInfos = [];\n\n        this._elements.forEach((elInfo, el) => {\n            /*\n             * Check if the element remained the same size. We can ignore\n             * these.\n             */\n            if (elInfo.oldHeight !== elInfo.newHeighht) {\n                elInfo.el = el;\n                elInfos.push(elInfo);\n            }\n        });\n\n        let scrollY = this._oldScrollY;\n\n        if (this._useScrollYOffset) {\n            scrollY -= this.scrollYOffset;\n        }\n\n        if (elInfos.length > 0) {\n            /* Try to put these in order by position. */\n            elInfos.sort((a, b) => a.newOffset.top - b.newOffset.top);\n\n            for (let i = 0; i < elInfos.length; i++) {\n                const elInfo = elInfos[i];\n\n                /* Check if the element precedes the current scroll position. */\n                if (elInfo.newOffset.top + elInfo.newHeight < scrollY) {\n                    scrollY += (elInfo.newHeight - elInfo.oldHeight) +\n                               (elInfo.newOffset.top - elInfo.oldOffset.top);\n                }\n            }\n        }\n\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        this._elements.clear();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n        this._updateScrollPosScheduled = false;\n    },\n});\n\n\nRB.scrollManager = new RB.ScrollManagerView();\n"]}