
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import extend_opview_class as _ods_extend_opview_class, segmented_accessor as _ods_segmented_accessor, equally_sized_accessor as _ods_equally_sized_accessor, get_default_loc_context as _ods_get_default_loc_context, get_op_result_or_value as _get_op_result_or_value, get_op_results_or_values as _get_op_results_or_values
_ods_ir = _ods_cext.ir

try:
  from . import _structured_transform_ops_ext as _ods_ext_module
except ImportError:
  _ods_ext_module = None

import builtins


from ._transform_ops_gen import _Dialect

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class DecomposeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.decompose"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class FuseOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.fuse"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, loops, target, *, tile_sizes=None, tile_interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    attributes["tile_sizes"] = tile_sizes if tile_sizes is not None else _ods_ir.ArrayAttr.get([])
    attributes["tile_interchange"] = tile_interchange if tile_interchange is not None else _ods_ir.ArrayAttr.get([])
    results.append(transformed)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class GeneralizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.generalize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class InterchangeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.interchange"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, iterator_interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    attributes["iterator_interchange"] = iterator_interchange if iterator_interchange is not None else _ods_ir.ArrayAttr.get([])
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class PadOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.pad"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, padding_values=None, padding_dimensions=None, pack_paddings=None, hoist_paddings=None, transpose_paddings=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    attributes["padding_values"] = padding_values if padding_values is not None else _ods_ir.ArrayAttr.get([])
    attributes["padding_dimensions"] = padding_dimensions if padding_dimensions is not None else _ods_ir.ArrayAttr.get([])
    attributes["pack_paddings"] = pack_paddings if pack_paddings is not None else _ods_ir.ArrayAttr.get([])
    attributes["hoist_paddings"] = hoist_paddings if hoist_paddings is not None else _ods_ir.ArrayAttr.get([])
    attributes["transpose_paddings"] = transpose_paddings if transpose_paddings is not None else _ods_ir.ArrayAttr.get([])
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def transformed(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class ScalarizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.scalarize"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, target, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    results.append(result)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.split"

  _ODS_REGIONS = (0, True)

  def __init__(self, first, second, target, dimension, static_split_point, *, dynamic_split_point=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    if dynamic_split_point is not None: operands.append(_get_op_result_or_value(dynamic_split_point))
    attributes["dimension"] = dimension
    attributes["static_split_point"] = static_split_point
    results.append(first)
    results.append(second)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def dynamic_split_point(self):
    return None if len(self.operation.operands) < 2 else self.operation.operands[1]

  @builtins.property
  def dimension(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["dimension"])

  @dimension.setter
  def dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["dimension"] = value

  @builtins.property
  def static_split_point(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["static_split_point"])

  @static_split_point.setter
  def static_split_point(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["static_split_point"] = value

  @builtins.property
  def first(self):
    return self.operation.results[0]

  @builtins.property
  def second(self):
    return self.operation.results[1]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class SplitReductionOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.split_reduction"

  _ODS_REGIONS = (0, True)

  def __init__(self, init_or_alloc_op, fill_op, split_linalg_op, combining_linalg_op, target, *, split_factor=None, insert_split_dimension=None, use_scaling_algorithm=None, use_alloc=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    assert split_factor is not None, "attribute split_factor must be specified"
    attributes["split_factor"] = split_factor
    assert insert_split_dimension is not None, "attribute insert_split_dimension must be specified"
    attributes["insert_split_dimension"] = insert_split_dimension
    if bool(use_scaling_algorithm): attributes["use_scaling_algorithm"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    if bool(use_alloc): attributes["use_alloc"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    results.append(init_or_alloc_op)
    results.append(fill_op)
    results.append(split_linalg_op)
    results.append(combining_linalg_op)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def split_factor(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["split_factor"])

  @split_factor.setter
  def split_factor(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["split_factor"] = value

  @builtins.property
  def insert_split_dimension(self):
    return _ods_ir.IntegerAttr(self.operation.attributes["insert_split_dimension"])

  @insert_split_dimension.setter
  def insert_split_dimension(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["insert_split_dimension"] = value

  @builtins.property
  def use_scaling_algorithm(self):
    return "use_scaling_algorithm" in self.operation.attributes

  @use_scaling_algorithm.setter
  def use_scaling_algorithm(self, value):
    if bool(value):
      self.operation.attributes["use_scaling_algorithm"] = _ods_ir.UnitAttr.get()
    elif "use_scaling_algorithm" in self.operation.attributes:
      del self.operation.attributes["use_scaling_algorithm"]

  @use_scaling_algorithm.deleter
  def use_scaling_algorithm(self):
    del self.operation.attributes["use_scaling_algorithm"]

  @builtins.property
  def use_alloc(self):
    return "use_alloc" in self.operation.attributes

  @use_alloc.setter
  def use_alloc(self, value):
    if bool(value):
      self.operation.attributes["use_alloc"] = _ods_ir.UnitAttr.get()
    elif "use_alloc" in self.operation.attributes:
      del self.operation.attributes["use_alloc"]

  @use_alloc.deleter
  def use_alloc(self):
    del self.operation.attributes["use_alloc"]

  @builtins.property
  def init_or_alloc_op(self):
    return self.operation.results[0]

  @builtins.property
  def fill_op(self):
    return self.operation.results[1]

  @builtins.property
  def split_linalg_op(self):
    return self.operation.results[2]

  @builtins.property
  def combining_linalg_op(self):
    return self.operation.results[3]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class TileOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.tile"

  _ODS_REGIONS = (0, True)

  def __init__(self, tiled_linalg_op, loops, target, *, sizes=None, interchange=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    attributes["sizes"] = sizes if sizes is not None else _ods_ir.ArrayAttr.get([])
    attributes["interchange"] = interchange if interchange is not None else _ods_ir.ArrayAttr.get([])
    results.append(tiled_linalg_op)
    results.extend(loops)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def tiled_linalg_op(self):
    return self.operation.results[0]

  @builtins.property
  def loops(self):
    _ods_variadic_group_length = len(self.operation.results) - 2 + 1
    return self.operation.results[1:1 + _ods_variadic_group_length]

@_ods_cext.register_operation(_Dialect)
@_ods_extend_opview_class(_ods_ext_module)
class VectorizeOp(_ods_ir.OpView):
  OPERATION_NAME = "transform.structured.vectorize"

  _ODS_REGIONS = (0, True)

  def __init__(self, transformed, target, *, vectorize_padding=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(target))
    assert vectorize_padding is not None, "attribute vectorize_padding must be specified"
    attributes["vectorize_padding"] = vectorize_padding
    results.append(transformed)
    _ods_successors = None
    super().__init__(self.build_generic(
      attributes=attributes, results=results, operands=operands,
      successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def target(self):
    return self.operation.operands[0]

  @builtins.property
  def vectorize_padding(self):
    return _ods_ir.BoolAttr(self.operation.attributes["vectorize_padding"])

  @vectorize_padding.setter
  def vectorize_padding(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["vectorize_padding"] = value

  @builtins.property
  def transformed(self):
    return self.operation.results[0]
