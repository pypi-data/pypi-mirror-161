# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['aiohttp_catcher', 'aiohttp_catcher.canned']

package_data = \
{'': ['*']}

install_requires = \
['aiohttp>=3.8.1,<4.0.0']

setup_kwargs = {
    'name': 'aiohttp-catcher',
    'version': '0.3.2',
    'description': 'A centralized error handler for aiohttp servers',
    'long_description': '# aiohttp-catcher\n\n<div align="left">\n  <a href="https://github.com/yuvalherziger/aiohttp-catcher/actions?query=workflow%3ACI"><img alt="CI Job"  height="20" src="https://github.com/yuvalherziger/aiohttp-catcher/workflows/CI/badge.svg"></a>\n  <a href="https://pypi.org/project/aiohttp-catcher"><img src="https://badge.fury.io/py/aiohttp-catcher.svg" alt="PyPI version" height="20"></a>\n  <a href="https://github.com/yuvalherziger/aiohttp-catcher/actions"><img src="https://gist.githubusercontent.com/yuvalherziger/14417a5617e959df89a524f327f86c92/raw/395fe027d00c73a612a117cc81c882d9ad012abc/aiohttp-catcher-cov.svg" height="20"></a>\n    <a href="https://github.com/yuvalherziger/aiohttp-catcher/blob/main/LiCENSE"><img src="https://img.shields.io/pypi/l/aiohttp-catcher?color=%233383FF" height="20"></a>\n    <a href="https://github.com/yuvalherziger/aiohttp-catcher"><img src="https://img.shields.io/pypi/dm/aiohttp-catcher?color=%23784212" height="20"></a>\n</div>\n\n***\n\naiohttp-catcher is a centralized error handler for [aiohttp servers](https://docs.aiohttp.org/en/stable/web.html).\nIt enables consistent error handling across your web server or API, so your code can raise Python exceptions that\nwill be mapped to consistent, user-friendly error messages.\n\n***\n\n- [Quickstart](#quickstart)\n- [What\'s New in 0.3.0?](#what-s-new-in-030-)\n- [Key Features](#key-features)\n  * [Return a Constant](#return-a-constant)\n  * [Stringify the Exception](#stringify-the-exception)\n  * [Canned HTTP 4xx and 5xx Errors (aiohttp Exceptions)](#canned-http-4xx-and-5xx-errors--aiohttp-exceptions-)\n  * [Callables and Awaitables](#callables-and-awaitables)\n  * [Handle Several Exceptions Similarly](#handle-several-exceptions-similarly)\n  * [Scenarios as Dictionaries](#scenarios-as-dictionaries)\n  * [Additional Fields](#additional-fields)\n  * [Default for Unhandled Exceptions](#default-for-unhandled-exceptions)\n- [Development](#development)\n\n***\n\nTL;DR:\n\n![aiohttp-catcher-diagram](img/aiohttp-catcher-diagram.png)\n\n***\n\n## Quickstart\n\nInstall aiohttp-catcher:\n\n```shell\npip install aiohttp-catcher\n```\n\nStart catching errors in your aiohttp-based web server:\n\n```python\nfrom aiohttp import web\nfrom aiohttp_catcher import catch, Catcher\n\nasync def divide(request):\n  quotient = 1 / 0\n  return web.Response(text=f"1 / 0 = {quotient}")\n\n\nasync def main():\n  # Add a catcher:\n  catcher = Catcher()\n\n  # Register error-handling scenarios:\n  await catcher.add_scenario(\n    catch(ZeroDivisionError).with_status_code(400).and_return("Zero division makes zero sense")\n  )\n\n  # Register your catcher as an aiohttp middleware:\n  app = web.Application(middlewares=[catcher.middleware])\n  app.add_routes([web.get("/divide-by-zero", divide)])\n  web.run_app(app)\n```\n\nMaking a request to `/divide-by-zero` will return a 400 status code with the following body:\n```json\n{"code": 400, "message": "Zero division makes zero sense"}\n```\n\n<div>\n<h3>\n  <span style="color:#ff6500">IMPORTANT NOTE:</span>\n  <span>aiohttp\'s order of middleware matters</span>\n</h3>\n</div>\n\nMiddlewares that are appended further in the list of your app\'s middlewares act\nearlier. Consider the following example:\n```python\napp = web.Application(middlewares=[middleware1, middleware2])\n```\n\nIn the above case, `middleware2` will be triggered first, and only then\nwill `middleware1` be triggered.  This means two things:\n\n1. If you register another middleware that catches exceptions but doesn\'t raise them\n   when it\'s done, you will need to add it **before** your _aiohttp-catcher_ middleware\n   or the other middleware will shadow _aiohttp-catcher_.\n2. If you register another middleware that relies on exceptions being raised, you want\n   to make sure it\'s added **after** your _aiohttp-catcher_ middleware, to avoid having\n   your _aiohttp-catcher_ middleware shadow the other middleware. One good example is\n   [aiohttp-debugtoolbar](https://github.com/aio-libs/aiohttp-debugtoolbar), which, like\n   _aiohttp-catcher_, expects exceptions to be thrown and raises them when its middleware\'s\n   execution is done. In this case, you want to set up _aiohttp-debugtoolbar_ after appending\n   your _aiohttp-catcher_ middleware.\n\n***\n\n## What\'s New in 0.3.0?\n\n* **Canned Scenarios:** You can now use a [canned list of scenarios](#canned-http-4xx-and-5xx-errors--aiohttp-exceptions-),\n  capturing all of [aiohttp\'s web exceptions](https://docs.aiohttp.org/en/latest/web_exceptions.html) out of the box.\n* **More flexible Callables and Awaitables:** Callables and Awaitables are now invoked with a second argument,  \n  the aiohttp `Request` instance, to add more flexibility to custom messages.\n\n***\n\n## Key Features\n\n### Return a Constant\n\nIn case you want some exceptions to return a constant message across your application, you can do\nso by using the `and_return("some value")` method:\n\n```python\nawait catcher.add_scenario(\n  catch(ZeroDivisionError).with_status_code(400).and_return("Zero division makes zero sense")\n)\n```\n\n***\n\n### Stringify the Exception\n\nIn some cases, you would want to return a stringified version of your exception, should it entail\nuser-friendly information.\n\n```python\nclass EntityNotFound(Exception):\n  def __init__(self, entity_id, *args, **kwargs):\n    super(EntityNotFound, self).__init__(*args, **kwargs)\n    self.entity_id = entity_id\n\n  def __str__(self):\n    return f"Entity {self.entity_id} could not be found"\n\n\n@routes.get("/user/{user_id}")\nasync def get_user(request):\n  user_id = request.match_info.get("user_id")\n  if user_id not in user_db:\n    raise EntityNotFound(entity_id=user_id)\n  return user_db[user_id]\n\n# Your catcher can be directed to stringify particular exceptions:\n\nawait catcher.add_scenario(\n  catch(EntityNotFound).with_status_code(404).and_stringify()\n)\n```\n\n***\n\n### Canned HTTP 4xx and 5xx Errors (aiohttp Exceptions)\n\nAs of version [0.3.0](https://github.com/yuvalherziger/aiohttp-catcher/releases/tag/0.3.0), you\ncan register [all of aiohttp\'s web exceptions](https://docs.aiohttp.org/en/latest/web_exceptions.html).\nThis is particularly useful when you want to ensure all possible HTTP errors are handled consistently.\n\nRegister the canned HTTP errors in the following way:\n\n```python\nfrom aiohttp import web\nfrom aiohttp_catcher import Catcher\nfrom aiohttp_catcher.canned import AIOHTTP_SCENARIOS\n\n\nasync def main():\n  # Add a catcher:\n  catcher = Catcher()\n  # Register aiohttp web errors:\n  await catcher.add_scenario(*AIOHTTP_SCENARIOS)\n  # Register your catcher as an aiohttp middleware:\n  app = web.Application(middlewares=[catcher.middleware])\n  web.run_app(app)\n```\n\nOnce you\'ve registered the canned errors, you can rely on aiohttp-catcher to convert errors raised by aiohttp\nto user-friendly error messages.  For example, `curl`ing a non-existent route in your server will return the\nfollowing error out of the box:\n\n```json\n{"code": 404, "message": "HTTPNotFound"}\n```\n\n***\n\n### Callables and Awaitables\n\nIn some cases, you\'d want the message returned by your server for some exceptions to call a custom\nfunction.  This function can either be a synchronous function or an awaitable one.  Your function should expect\ntwo arguments:\n\n1. The exception being raised by handlers.\n2. The request object - an instance of `aiohttp.web.Request`.\n\n```python\nfrom aiohttp.web import Request\nfrom aiohttp_catcher import catch, Catcher\n\n# Can be a synchronous function:\nasync def write_message(exc: Exception, request: Request):\n  return "Whoops"\n\ncatcher = Catcher()\nawait catcher.add_scenarios(\n  catch(MyCustomException2).with_status_code(401).and_call(write_message),\n  catch(MyCustomException2).with_status_code(403).and_call(lambda exc: str(exc))\n)\n\n```\n\n***\n\n### Handle Several Exceptions Similarly\n\nYou can handle several exceptions in the same manner by adding them to the same scenario:\n\n```python\nawait catcher.add_scenario(\n  catch(\n    MyCustomException1,\n    MyCustomException2,\n    MyCustomException3\n  ).with_status_code(418).and_return("User-friendly error message")\n)\n```\n\n***\n\n### Scenarios as Dictionaries\n\nYou can register your scenarios as dictionaries as well:\n\n```python\nawait catcher.add_scenarios(\n  {\n    "exceptions": [ZeroDivisionError],\n    "constant": "Zero division makes zero sense",\n    "status_code": 400,\n  },\n  {\n    "exceptions": [EntityNotFound],\n    "stringify_exception": True,\n    "status_code": 404,\n  },\n  {\n    "exceptions": [IndexError],\n    "func": lambda exc: f"Out of bound: {str(exc)}",\n    "status_code": 418,\n  },\n)\n```\n\n***\n\n### Additional Fields\n\nYou can enrich your error responses with additional fields. You can provide additional fields using\nliteral dictionaries or with callables.  Your function should expect two arguments:\n\n1. The exception being raised by handlers.\n2. The request object - an instance of `aiohttp.web.Request`.\n\n```python\n# Using a literal dictionary:\nawait catcher.add_scenario(\n  catch(EntityNotFound).with_status_code(404).and_stringify().with_additional_fields({"error_code": "ENTITY_NOT_FOUND"})\n)\n\n# Using a function (or an async function):\nawait catcher.add_scenario(\n  catch(EntityNotFound).with_status_code(404).and_stringify().with_additional_fields(\n    lambda exc, req: {"error_code": e.error_code, "method": req.method}\n  )\n)\n```\n\n***\n\n### Default for Unhandled Exceptions\n\nExceptions that aren\'t registered with scenarios in your `Catcher` will default to 500, with a payload similar to\nthe following:\n\n```json\n{"code": 500, "message": "Internal server error"}\n```\n\n***\n\n## Development\n\nContributions are warmly welcomed.  Before submitting your PR, please run the tests using the following Make target:\n\n```bash\nmake ci\n```\n\nAlternatively, you can run each test separately:\n\nUnit tests:\n\n```bash\nmake test/py\n```\n\nLinting with pylint:\n\n```bash\nmake pylint\n```\n\nStatic security checks with bandit:\n\n```bash\nmake pybandit\n```\n',
    'author': 'Yuval Herziger',
    'author_email': 'yuvalhrz@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://github.com/yuvalherziger/aiohttp-catcher',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
