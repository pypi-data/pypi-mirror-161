{"version":3,"file":"lib_index_js.a4a3e5d1150e7a5b5586.js","mappings":";;;;;;;;;;;;;;;;;AAA+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AClCuC;AACS;AACzC;AACP,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAU;AACrC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,2CAA2C;AAC3C,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,oDAAoD;AAChG,qCAAqC;AACrC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA,8CAA8C;AAC9C,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,0EAA0E,eAAe;AACzF;AACA;AACA;AACA;AACO,gDAAgD,oDAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oDAAU;AAC5C,2BAA2B,UAAU,IAAI,QAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://@educational-technology-collective/etc_jupyterlab_notebook_state_provider/./lib/handler.js","webpack://@educational-technology-collective/etc_jupyterlab_notebook_state_provider/./lib/index.js"],"sourcesContent":["import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'etc-jupyterlab-notebook-state-provider', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import { requestAPI } from './handler';\nimport { UUID, Token } from '@lumino/coreutils';\nexport class ETCJupyterLabNotebookState {\n    constructor({ notebookPanel }) {\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        this._nbFormatNotebook = null;\n        this._cellState = new WeakMap();\n        this._seq = 0;\n        this._session_id = UUID.uuid4();\n        (async () => {\n            var _a;\n            await notebookPanel.revealed;\n            this.updateCellState();\n            //  The notebook loaded; hence, update the cell state.\n            (_a = notebookPanel.content.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect((sender, args) => {\n                this.updateCellState();\n                //  A cell event happened; hence, update the cell state.\n            }, this);\n        })();\n    }\n    updateCellState() {\n        this._notebook.widgets.forEach((cell) => {\n            if (!this._cellState.has(cell)) {\n                this._cellState.set(cell, { changed: true, output: this.createCellOutput(cell) });\n                //  It's a new cell; hence, the changed state is set to true.\n                ////  This is a new cell; hence, add handlers that check for changes in the inputs and outputs.\n                cell.inputArea.model.value.changed.connect((sender, args) => {\n                    let state = this._cellState.get(cell);\n                    if (state !== undefined) {\n                        state.changed = true;\n                        //  The input area changed; hence, the changed state is set to true.\n                    }\n                });\n                if (cell.model.type == 'code') {\n                    cell.model.outputs.changed.connect((sender, args) => {\n                        if (args.type == 'add') {\n                            //  An output has been added to the cell; hence, compare the current state with the new state.\n                            let state = this._cellState.get(cell);\n                            if (state !== undefined) {\n                                let output = this.createCellOutput(cell);\n                                if (output !== (state === null || state === void 0 ? void 0 : state.output)) {\n                                    //  The output has changed; hence, set changed to true and update the output state.\n                                    state.changed = true;\n                                    state.output = output;\n                                }\n                                else {\n                                    //  The output hasn't changed; hence, leave the state as is.\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createCellOutput(cell) {\n        //  Combine the cell outputs into a string in order to check for changes.\n        let output = '';\n        if (cell.model.type == 'code') {\n            let outputs = cell.model.outputs;\n            for (let index = 0; index < outputs.length; index++) {\n                for (let key of Object.keys(outputs.get(index).data).sort()) {\n                    output = output + JSON.stringify(outputs.get(index).data[key]);\n                }\n            }\n            return output;\n        }\n        return '';\n    }\n    getNotebookState() {\n        var _a;\n        this._nbFormatNotebook = ((_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.toJSON()) || this._nbFormatNotebook;\n        for (let index = 0; index < this._notebook.widgets.length; index++) {\n            let cell = this._notebook.widgets[index];\n            let cellState = this._cellState.get(cell);\n            if (cellState === undefined) {\n                throw new Error(`The cell at index ${index} is not tracked.`);\n            }\n            if (cellState.changed === false) {\n                //  The cell has not changed; hence, the notebook format cell will contain just its id.\n                this._nbFormatNotebook.cells[index] = { id: this._notebook.widgets[index].model.id };\n            }\n            else {\n                this._nbFormatNotebook.cells[index]['id'] = this._notebook.widgets[index].model.id;\n                //  This just ensures that the id was copied over in the call to toJSON.\n            }\n            //  Because it is possible for this to throw, as an extra precaution we don't\n            //  mark the cells as unchanged at this point; we do it in the following for loop\n            //  in order to ensure that it's *all or nothing* i.e., a transaction. \n        }\n        for (let index = 0; index < this._notebook.widgets.length; index++) {\n            let cell = this._notebook.widgets[index];\n            let cellState = this._cellState.get(cell);\n            if (cellState !== undefined) {\n                cellState.changed = false;\n            }\n            //  The cell state is going to be captured; hence, set the state to not changed.\n            //  Because it's possible for the first for loop to throw, we need to be\n            //  certain that all the cells were processed prior to making any changes \n            //  to their state; hence, this operation is done in this loop separate from \n            //  the first loop above.\n        }\n        let state = {\n            session_id: this._session_id,\n            seq: this._seq,\n            notebook: this._nbFormatNotebook\n        };\n        this._seq = this._seq + 1;\n        //  We've made changes to the state at this point. *All* sequences must be logged in order to \n        //  reconstruct a notebook; hence, it's really important that nothing throws between now and \n        //  recording the message.\n        return state;\n    }\n}\nexport class ETCJupyterLabNotebookStateProvider {\n    constructor() {\n        this._notebookPanelMap = new WeakMap();\n    }\n    getNotebookState({ notebookPanel }) {\n        let notebookState = this._notebookPanelMap.get(notebookPanel);\n        return notebookState === null || notebookState === void 0 ? void 0 : notebookState.getNotebookState();\n    }\n    addNotebookPanel({ notebookPanel }) {\n        let etcJupyterLabNotebookState = new ETCJupyterLabNotebookState({ notebookPanel });\n        this._notebookPanelMap.set(notebookPanel, etcJupyterLabNotebookState);\n    }\n}\nconst PLUGIN_ID = '@educational-technology-collective/etc_jupyterlab_notebook_state_provider:plugin';\nexport const IETCJupyterLabNotebookStateProvider = new Token(PLUGIN_ID);\n/**\n * Initialization data for the @educational-technology-collective/etc_jupyterlab_notebook_state extension.\n */\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    provides: IETCJupyterLabNotebookStateProvider,\n    activate: async (app) => {\n        try {\n            const VERSION = await requestAPI('version');\n            console.log(`${PLUGIN_ID}, ${VERSION}`);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        finally {\n            return new ETCJupyterLabNotebookStateProvider();\n        }\n    }\n};\nexport default plugin;\n"],"names":[],"sourceRoot":""}